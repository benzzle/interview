<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .pad{
        width: 300px;
        height: 300px;
        display: flex;
        background: pink;
        justify-content: space-between;
      }
      .bed{
        width: 70px;
        height: 70px;
        background-color: olive;
      }
      .bed:nth-child(2) {
        align-self: center;
      }

      .bed:nth-child(3) {
        align-self: flex-end;
      }
    </style>
  </head>
  <body>
    <div class="pad">
      <div class="bed"></div>
      <div class="bed"></div>
      <div class="bed"></div>
    </div>
    <script>
      // 使用如下版本
      Function.prototype.bind0 =  function(thisArg, ...args){
        if(typeof this !== 'function') return
        const _self = this
        const fn = function(...args1){
          const _this = this instanceof _self ? this: thisArg
          _self.apply(_this, [...args, ...args1])
        }
        fn.prototype= this.prototype
        return fn
      }




      const module = {
        name: '小明',
        getName: function() {
          return this.name;
        }
      };
      console.log(module.getName())
      const unbound = module.getName;
      console.log(unbound()); // undefined
      const bound = unbound.bind(module); // 把 unboundGetX 的 this 绑定成module
      console.log(bound());


      Function.prototype.myBind = function (thisArg) {
        if (typeof this !== "function") return
        var _self = this;
        var args = [...arguments].slice(1)
        // var args = Array.prototype.slice.call(arguments, 1);
        var fnBound = function () {
          // 检测 New
          // 如果当前函数的this指向的是构造函数中的this 则判定为new 操作
          var _this = this instanceof _self ? this : thisArg;
          return _self.apply(
            _this,
            args.concat(Array.prototype.slice.call(arguments))
          );
        };
        // 为了完成 new操作
        // 还需要做一件事情 执行原型 链接 （思考题，为什么？
        fnBound.prototype = this.prototype;
        return fnBound;
      };

      function foo(name) {
        this.name = name;
      }
      var obj = {};
      var bar = foo.bind0(obj);
      bar("Jack");
      console.log(obj.name); // Jack
      var alice = new bar("Alice");
      console.log(obj.name); // Jack
      console.log(alice.name); // Alice

      // const temp = new Fn(args)
      /*
        const temp = {}
        temp.__proto__ = Fn.prototype
        Fn.call(temp, ...args)
        return temp
      */

    </script>
  </body>
</html>
